package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	_ "net/http/pprof"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"
	"sync"
	"time"

	"github.com/mjl-/gobuild/internal/sumdb"

	"github.com/mjl-/httpinfo"
	"github.com/mjl-/sconf"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"golang.org/x/crypto/acme/autocert"
	"golang.org/x/mod/sumdb/note"
	"golang.org/x/mod/sumdb/tlog"
)

var (
	workdir        string
	homedir        string
	gobuildVersion = "(no module)"

	recentBuilds struct {
		sync.Mutex
		paths []string // as returned by request.urlPath
	}

	config = struct {
		GoProxy      string   `sconf-doc:"URL to Go module proxy. Used to resolve \"latest\" module versions."`
		DataDir      string   `sconf-doc:"Directory where the sumdb and builds files (binary, log, sha256) are stored."`
		SDKDir       string   `sconf-doc:"Directory where SDKs (go toolchains) are installed."`
		HomeDir      string   `sconf-doc:"Directory set as home directory during builds. Go will store its caches, downloaded and extracted modules here."`
		MaxBuilds    int      `sconf-doc:"Maximum concurrent builds. Default (0) uses NumCPU+1."`
		Environment  []string `sconf:"optional" sconf-doc:"Additional environment variables in form KEY=VALUE to use for go command invocations. Useful to configure GOSUMDB."`
		Run          []string `sconf:"optional" sconf-doc:"Command and parameters to prefix invocations of go with. For example /usr/bin/nice."`
		VerifierURLs []string `sconf:"optional" sconf-doc:"URLs of other gobuild instances that are asked to perform the same build. Gobuild requires all of them to create the same binary (same hash) for a build to be successful. Ideally, these instances differ in hardware, goos, goarch, user id/name, home and work directories."`
		HTTPS        *struct {
			ACME struct {
				Domains []string `sconf-doc:"List of domains to serve HTTPS for and request certificates for with ACME."`
				Email   string   `sconf-doc:"Contact email address to use when requesting certificates through ACME. CAs will contact this address in case of problems or expiry of certificates."`
				CertDir string   `sconf-doc:"Directory to stored certificates in."`
			} `sconf-doc:"ACME configuration."`
		} `sconf:"optional" sconf-doc:"HTTPS configuration, if any."`
		SignerKey string `sconf:"optional" sconf-doc:"Signer key as generated by subcommand genkey, for signing the transparent log."`
	}{
		"https://proxy.golang.org/",
		"data",
		"sdk",
		"home",
		0,
		nil,
		nil,
		nil,
		nil,
		"",
	}
	emptyConfig = config

	// Opened at startup, used whenever we read/write to the hashes or records files.
	hashesFile, recordsFile *os.File
)

var errRemote = errors.New("remote")
var errServer = errors.New("server error")

func serve(args []string) {
	serveFlags := flag.NewFlagSet("serve", flag.ExitOnError)

	listenAdmin := serveFlags.String("listen-admin", "localhost:8001", "address to serve admin-related http on")
	listenHTTP := serveFlags.String("listen-http", "localhost:8000", "address to serve plain http on")

	serveFlags.Usage = func() {
		log.Println("usage: gobuild serve [flags] [gobuild.conf]")
		serveFlags.PrintDefaults()
	}
	serveFlags.Parse(args)
	args = serveFlags.Args()
	if len(args) > 1 {
		serveFlags.Usage()
		os.Exit(2)
	}
	if len(args) > 0 {
		err := sconf.ParseFile(args[0], &config)
		if err != nil {
			log.Fatalf("parsing config file: %v", err)
		}
	}
	if !strings.HasSuffix(config.GoProxy, "/") {
		config.GoProxy += "/"
	}
	for i, url := range config.VerifierURLs {
		if strings.HasSuffix(url, "/") {
			config.VerifierURLs[i] = config.VerifierURLs[i][:len(config.VerifierURLs[i])-1]
		}
	}

	if buildInfo, ok := debug.ReadBuildInfo(); ok {
		gobuildVersion = buildInfo.Main.Version
	}

	var err error
	workdir, err = os.Getwd()
	if err != nil {
		log.Fatalln("getwd:", err)
	}

	homedir = config.HomeDir
	if !filepath.IsAbs(homedir) {
		homedir = filepath.Join(workdir, config.HomeDir)
	}
	os.Mkdir(homedir, 0775) // failures will be caught later
	// We need a clean name: we will be match path prefixes against paths returned by
	// go tools, that will have evaluated names.
	homedir, err = filepath.EvalSymlinks(homedir)
	if err != nil {
		log.Fatalf("evaluating symlinks in homedir: %v", err)
	}
	os.Mkdir(config.SDKDir, 0775)                           // may already exist, we'll get errors later
	os.Mkdir(filepath.Join(config.DataDir, "result"), 0775) // may already exist, we'll get errors later
	os.Mkdir(filepath.Join(config.DataDir, "sum"), 0775)    // may already exist, we'll get errors later

	// Initialize data/sum/hashes and data/sum/records files.
	hashesPath := filepath.Join(config.DataDir, "sum", "hashes")
	recordsPath := filepath.Join(config.DataDir, "sum", "records")

	os.MkdirAll(filepath.Dir(hashesPath), 0777) // Errors will be caught below.
	hashesFile, err = os.OpenFile(hashesPath, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		log.Fatalf("creating hashes file: %v", err)
	}
	recordsFile, err = os.OpenFile(recordsPath, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		log.Fatalf("creating records file: %v", err)
	}

	// Verify records & hashes files have consistent sizes.
	numRecords, err := treeSize()
	if err != nil {
		log.Fatalf("finding number of records in tlog: %v", err)
	}
	if info, err := hashesFile.Stat(); err != nil {
		log.Fatalf("stat on hashes file: %v", err)
	} else if hashCount := tlog.StoredHashCount(numRecords); hashCount*tlog.HashSize != info.Size() {
		log.Fatalf("inconsistent size of hashes file of %d bytes for %d records, should be %d", info.Size(), numRecords, hashCount*tlog.HashSize)
	}

	// For the latest record on disk, verify the hashes on disk match the record.
	if numRecords > 0 {
		lastRecordNum := numRecords - 1
		records, err := server{}.ReadRecords(context.Background(), lastRecordNum, 1)
		if err != nil {
			log.Fatalf("reading last record: %v", err)
		}
		hashes, err := tlog.StoredHashes(lastRecordNum, records[0], hashReader{})
		if err != nil {
			log.Fatalf("calculating hashes for most recent record: %v", err)
		}
		buf := make([]byte, len(hashes)*tlog.HashSize)
		if _, err := hashesFile.ReadAt(buf, tlog.StoredHashIndex(0, lastRecordNum)*tlog.HashSize); err != nil {
			log.Fatalf("reading hashes for verification: %v", err)
		}
		for i := range hashes {
			o := i * tlog.HashSize
			h := buf[o : o+tlog.HashSize]
			if !bytes.Equal(hashes[i][:], h) {
				log.Fatalf("hash %d mismatch for last record %d, got %x, expect %x", i, lastRecordNum, h, hashes[i][:])
			}
		}
	}

	initSDK()
	readRecentBuilds()

	go coordinateBuilds()

	http.Handle("/metrics", promhttp.Handler())
	http.Handle("/info", httpinfo.NewHandler(httpinfo.CodeVersion{}, nil))

	mux := http.NewServeMux()
	mux.HandleFunc("/robots.txt", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain")
		fmt.Fprint(w, "User-agent: *\nDisallow: /b/\n")
	})
	mux.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "image/png")
		w.Write(fileFaviconPng) // nothing to do for errors
	})

	mux.HandleFunc("/emptyconfig", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain")
		sconf.Describe(w, &emptyConfig) // nothing to do for errors
	})

	if config.SignerKey != "" {
		signer, err := note.NewSigner(config.SignerKey)
		if err != nil {
			log.Fatalf("new signer: %v", err)
		}

		h := http.StripPrefix("/tlog", sumdb.NewServer(server{signer}))
		for _, path := range sumdb.ServerPaths {
			mux.Handle("/tlog"+path, h)
		}
	}

	mux.HandleFunc("/m/", http.HandlerFunc(serveModules))
	mux.HandleFunc("/b/", http.HandlerFunc(serveBuild))
	mux.HandleFunc("/r/", http.HandlerFunc(serveResult))
	mux.HandleFunc("/img/gopher-dance-long.gif", func(w http.ResponseWriter, r *http.Request) {
		defer observePage("dance", time.Now())
		w.Header().Set("Content-Type", "image/gif")
		w.Write(fileGopherDanceLongGif) // nothing to do for errors
	})
	mux.HandleFunc("/", serveHome)
	msg := "listening on"
	if *listenHTTP != "" {
		msg += " http " + *listenHTTP
		go func() {
			log.Fatal(http.ListenAndServe(*listenHTTP, mux))
		}()
	}
	if config.HTTPS != nil {
		msg += " https :443"
		os.MkdirAll(config.HTTPS.ACME.CertDir, 0700) // errors will come up later
		m := &autocert.Manager{
			Prompt:     autocert.AcceptTOS,
			HostPolicy: autocert.HostWhitelist(config.HTTPS.ACME.Domains...),
			Cache:      autocert.DirCache(config.HTTPS.ACME.CertDir),
			Email:      config.HTTPS.ACME.Email,
		}
		go func() {
			log.Fatal(http.Serve(m.Listener(), mux))
		}()
	}
	if *listenAdmin != "" {
		msg += " admin " + *listenAdmin
		go func() {
			log.Fatal(http.ListenAndServe(*listenAdmin, nil))
		}()
	}
	log.Print(msg)
	select {}
}

func failf(w http.ResponseWriter, format string, args ...interface{}) {
	err := fmt.Errorf(format, args...)
	msg := err.Error()
	if errors.Is(err, errServer) {
		log.Println(msg)
		http.Error(w, "500 - "+msg, http.StatusInternalServerError)
		return
	}
	http.Error(w, "400 - "+msg, http.StatusBadRequest)
}

func serveLog(w http.ResponseWriter, r *http.Request, p string) {
	f, err := os.Open(p)
	if err != nil {
		failf(w, "%w: open log.gz: %v", errServer, err)
		return
	}
	defer f.Close()
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	serveGzipFile(w, r, p, f)
}

func serveGzipFile(w http.ResponseWriter, r *http.Request, path string, src io.Reader) {
	if acceptsGzip(r) {
		w.Header().Set("Content-Encoding", "gzip")
		io.Copy(w, src) // nothing to do for errors
	} else {
		gzr, err := gzip.NewReader(src)
		if err != nil {
			failf(w, "%w: decompressing %q: %s", errServer, path, err)
			return
		}
		io.Copy(w, gzr) // nothing to do for errors
	}
}
